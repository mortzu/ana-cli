#! /usr/bin/env python2
# 2014, Moritz Kaspar Rudert (mortzu) <mr@planetcyborg.de>
# All rights reserved.

# Redistribution and use in source and binary forms, with or without modification, are
# permitted provided that the following conditions are met:
#
# * Redistributions of source code must retain the above copyright notice, this list of
#   conditions and the following disclaimer.
#
# * Redistributions in binary form must reproduce the above copyright notice, this list
#   of conditions and the following disclaimer in the documentation and/or other materials
#   provided with the distribution.
#
# * The names of its contributors may not be used to endorse or promote products derived
#   from this software without specific prior written permission.
#
# * Feel free to send Club Mate to support the work.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS
# OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY
# AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDERS
# AND CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
# SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
# THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
# OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.

# import base stuff
import sys

# module which parses commandline arguments
import argparse

# to read interactivly passwords echo-less
from getpass import getpass

# https requests with digest auth
import pycurl
try:
    from io import BytesIO
except ImportError:
    from io import StringIO as BytesIO

# json. the name tells all
import json

# url escape
import urllib

import texttable

from xdg import BaseDirectory

import yaml

# check for python3
python3 = sys.version_info[0] > 2

# function to print message to STDERR
def print_error(message):
    sys.stderr.write(str(message) + "\n")
    sys.exit(1)

# do API call
def api_call(api_url, action):
    buf = BytesIO()
    # do the request
    curl = pycurl.Curl()
    curl.setopt(pycurl.URL, api_url + action)
    curl.setopt(pycurl.WRITEFUNCTION, buf.write)
    curl.perform()
    response_code = curl.getinfo(curl.RESPONSE_CODE)
    curl.close()
    api_content = buf.getvalue().decode('UTF-8')
    json_content = json.loads(api_content)

    # catch errors
    if response_code == 401:
        print_error('Invalid credentials!')
    elif response_code == 404:
        print_error('User not found!')
    elif response_code != 200:
        print_error('Something went terribly wrong!')

    # return json dict
    return json_content

def main():
#    self.configfile = os.path.join(BaseDirectory.xdg_config_home, 'ana-cli.conf')

#    if os.path.isfile(self.configfile):
#        with open("config.yml", 'r') as ymlfile:
#    cfg = yaml.load(ymlfile)

    parser = argparse.ArgumentParser()

    subparsers = parser.add_subparsers(dest = 'subparser_name', help = 'commands')

    login_parser = subparsers.add_parser('login', help = '')
    login_parser.add_argument('--name', action = 'store', help = 'Name of API connector', required = True)
    login_parser.add_argument('--token', action = 'store', help = 'API token', required = True)

    domain_attach_parser = subparsers.add_parser('attach', help = 'Attach to specified domain instance')
    domain_attach_parser.add_argument('name', action = 'store', help = 'Name of instance')

    domain_create_parser = subparsers.add_parser('create', help = 'Create domain instance')
    domain_create_parser.add_argument('--name', action = 'store', help = 'Name of instance', required = True)
    domain_create_parser.add_argument('--hostname', action = 'store', help = 'Container host name')
    domain_create_parser.add_argument('-c', '--cpu-shares', action = 'store', help = 'CPU shares (relative weight)')
    domain_create_parser.add_argument('-m', '--memory', action  = 'store', help = 'Memory limit', required = True)
    domain_create_parser.add_argument('--swap', action = 'store', help = 'Swapspace limit')
    domain_create_parser.add_argument('--size', action = 'store', help = 'Diskspace limit', required = True)

    domain_exec_parser = subparsers.add_parser('exec', help = 'Execute command at instance')
    domain_exec_parser.add_argument('name', action = 'store', help = 'Name of instance')

    domain_info_parser = subparsers.add_parser('info', help = 'Shows informations about specified domain instance')
    domain_info_parser.add_argument('name', action = 'store', help = 'Name of instance')

    domain_ps_parser = subparsers.add_parser('ps', help = 'Lists all domain instances')
    domain_ps_parser.add_argument('-a', action = 'store_true', help = 'Lists down instances too')

    domain_restart_parser = subparsers.add_parser('restart', help = 'Restarts domain instance gracefully')
    domain_restart_parser.add_argument('-t', '--term', action = 'store_true', help = 'Resets domain instance')

    domain_rm_parser = subparsers.add_parser('rm', help = 'Removes specified domain instance')
    domain_rm_parser.add_argument('name', action = 'store', help = 'Name of instance')

    domain_start_parser = subparsers.add_parser('start', help = 'Starts specified domain instance')
    domain_start_parser.add_argument('name', action = 'store', help = 'Name of instance')

    domain_stop_parser = subparsers.add_parser('stop', help = 'Stops specified domain instance')
    domain_stop_parser.add_argument('name', action = 'store', help = 'Name of instance')
    domain_stop_parser.add_argument('-t', '--term', action = 'store_true', help = 'Terminate instance')

    parser.add_argument('--version', action = 'version', version = '%(prog)s 1.0')

    results = parser.parse_args()

    if results.subparser_name == 'login':
        print results.name
        print results.token

    elif results.subparser_name == 'attach':
        print results.name

    elif results.subparser_name == 'create':
        print results.name

    elif results.subparser_name == 'info':
        print results.name

    elif results.subparser_name == 'ps':
        table = texttable.Texttable()
        table.set_deco(texttable.Texttable.HEADER)
        header = ["NAME", "HOST", "STATUS"]
        table.header(header)

        json = api_call('https://admin.open.tf/api.php?token=ooqu4rahsh5aeZ5d', '&action=get_domains')
        for hostname, domains in json.iteritems():
            for domainname, domain in domains.iteritems():
                if domain['state'] == True or results.a == True:
                    table.add_row([domainname, hostname, str(domain['state'])])
        print table.draw()

    elif results.subparser_name == 'rm':
        print results.name

    elif results.subparser_name == 'start':
        json = api_call('https://admin.open.tf/api.php?token=', '&action=domain_start&name=' + results.name);
        print json

    elif results.subparser_name == 'stop':
        if results.t == True:
            json = api_call('https://admin.open.tf/api.php?token=', '&action=domain_stop&name=' + results.name);
        else:
            json = api_call('https://admin.open.tf/api.php?token=', '&action=domain_shutdown&name= ' + results.name);
        print json

if __name__ == "__main__":
    main()
