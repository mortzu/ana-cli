#! /usr/bin/env python2
# 2014, Moritz Kaspar Rudert (mortzu) <mr@planetcyborg.de>
# All rights reserved.

# Redistribution and use in source and binary forms, with or without modification, are
# permitted provided that the following conditions are met:
#
# * Redistributions of source code must retain the above copyright notice, this list of
#   conditions and the following disclaimer.
#
# * Redistributions in binary form must reproduce the above copyright notice, this list
#   of conditions and the following disclaimer in the documentation and/or other materials
#   provided with the distribution.
#
# * The names of its contributors may not be used to endorse or promote products derived
#   from this software without specific prior written permission.
#
# * Feel free to send Club Mate to support the work.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS
# OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY
# AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDERS
# AND CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
# SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
# THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
# OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.

# import base stuff
import sys

# module which parses commandline arguments
import argparse

# to read interactivly passwords echo-less
from getpass import getpass

# https requests with digest auth
import pycurl
try:
    from io import BytesIO
except ImportError:
    from io import StringIO as BytesIO

# json. the name tells all
import json

# url escape
import urllib

# check for python3
python3 = sys.version_info[0] > 2

# function to print message to STDERR
def print_error(message):
    sys.stderr.write(str(message) + "\n")
    sys.exit(1)

# do API call
def api_call(action, api_url, url, username, password):
    buf = BytesIO()
    # do the request
    curl = pycurl.Curl()
    curl.setopt(pycurl.URL, api_url + urllib.quote(action) + url)
    curl.setopt(pycurl.USERPWD, "%s:%s" % (username, password))
    curl.setopt(pycurl.HTTPAUTH, pycurl.HTTPAUTH_DIGEST)
    curl.setopt(pycurl.WRITEFUNCTION, buf.write)
    curl.perform()
    response_code = curl.getinfo(curl.RESPONSE_CODE)
    curl.close()
    api_content = buf.getvalue().decode('UTF-8')
    json_content = json.loads(api_content)

    # catch errors
    if response_code == 401:
        print_error('Invalid credentials!')
    elif response_code == 404:
        print_error('User not found!')
    elif response_code != 200:
        print_error('Something went terribly wrong!')

    # return json dict
    return json_content

def main():
    parser = argparse.ArgumentParser()

    subparsers = parser.add_subparsers(dest = 'subparser_name', help = 'commands')

    login_parser = subparsers.add_parser('login', help = '')
    login_parser.add_argument('--name', action = 'store', help = 'Name of API connector', required = True)
    login_parser.add_argument('--token', action = 'store', help = 'API token', required = True)

    domain_attach_parser = subparsers.add_parser('attach', help = 'Attach to specified domain instance')
    domain_attach_parser.add_argument('name', action = 'store', help = 'Name of instance')

    domain_create_parser = subparsers.add_parser('create', help = 'Create domain instance')
    domain_create_parser.add_argument('name', action = 'store', help = 'Name of instance')

    domain_info_parser = subparsers.add_parser('info', help = 'Shows informations about specified domain instance')
    domain_info_parser.add_argument('name', action = 'store', help = 'Name of instance')

    domain_ps_parser = subparsers.add_parser('ps', help = 'Lists all domain instances')
    domain_ps_parser.add_argument('-a', action = 'store_true', help = 'Lists down instances too')

    domain_rm_parser = subparsers.add_parser('rm', help = 'Removes specified domain instance')
    domain_rm_parser.add_argument('name', action = 'store', help = 'Name of instance')

    domain_start_parser = subparsers.add_parser('start', help = 'Starts specified domain instance')
    domain_start_parser.add_argument('name', action = 'store', help = 'Name of instance')

    domain_stop_parser = subparsers.add_parser('stop', help = 'Stops specified domain instance')
    domain_stop_parser.add_argument('name', action = 'store', help = 'Name of instance')
    domain_stop_parser.add_argument('-t', action = 'store_true', help = 'Terminate instance')

    parser.add_argument('--version', action = 'version', version = '%(prog)s 1.0')

    results = parser.parse_args()

    if results.subparser_name == 'login':
        print results.name
        print results.token
    elif results.subparser_name == 'attach':
        print results.name
    elif results.subparser_name == 'create':
        print results.name
    elif results.subparser_name == 'info':
        print results.name
    elif results.subparser_name == 'ps':
        print results.a
    elif results.subparser_name == 'rm':
        print results.name
    elif results.subparser_name == 'start':
        print results.name
    elif results.subparser_name == 'stop':
        print results.name
        print results.t

if __name__ == "__main__":
    main()
